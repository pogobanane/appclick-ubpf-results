path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107913068
Startup trace (nsec): print config: 109418631
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 550645097
Startup trace (nsec): initialize elements: 554258899
[    0.558208] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 565794322
[router_thread:310] Starting driver...


Received packet from device: 576547099 ns:  180 | 33330000 0016767e 90d49854 86dd6000 00000074 0001fe80
qemu-system-x86_64: terminating on signal 1 from pid 196430 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 920074049
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107859906
Startup trace (nsec): print config: 109357998
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 549311137
Startup trace (nsec): initialize elements: 552911036
[    0.556852] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 564419405
[router_thread:310] Starting driver...


Received packet from device: 575166825 ns:   64 | 01005e00 0016767e 90d49854 080046c0 00280000 40000102
qemu-system-x86_64: terminating on signal 1 from pid 196503 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 923394971
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107846167
Startup trace (nsec): print config: 109327705
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 547004216
Startup trace (nsec): initialize elements: 550590538
[    0.554497] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 562002360
[router_thread:310] Starting driver...


Received packet from device: 572686651 ns:  180 | 33330000 0016767e 90d49854 86dd6000 00000074 0001fe80
qemu-system-x86_64: terminating on signal 1 from pid 196593 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 915423880
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107772195
Startup trace (nsec): print config: 109252563
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 545497571
Startup trace (nsec): initialize elements: 549062060
[    0.552964] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 560405287
[router_thread:310] Starting driver...


Received packet from device: 571092453 ns:  120 | 33330000 0016feac a58bbef9 86dd6000 00000038 00010000
qemu-system-x86_64: terminating on signal 1 from pid 196674 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 914303383
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 108086225
Startup trace (nsec): print config: 109598018
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 553337662
Startup trace (nsec): initialize elements: 556965471
[    0.560949] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 568556415
[router_thread:310] Starting driver...


Received packet from device: 579420787 ns:  120 | 33330000 0016fe32 a5c26109 86dd6000 00000038 00010000
qemu-system-x86_64: terminating on signal 1 from pid 196752 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 923737686
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107742275
Startup trace (nsec): print config: 109229337
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 547942140
Startup trace (nsec): initialize elements: 551519883
[    0.555431] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 562873077
[router_thread:310] Starting driver...


Received packet from device: 573643687 ns:  180 | 33330000 0016767e 90d49854 86dd6000 00000074 0001fe80
qemu-system-x86_64: terminating on signal 1 from pid 196830 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 917144288
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107791829
Startup trace (nsec): print config: 109284085
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 546795134
Startup trace (nsec): initialize elements: 550371827
[    0.554284] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 561723542
[router_thread:310] Starting driver...


Received packet from device: 572481756 ns:  120 | 33330000 0016fe67 b11f89bb 86dd6000 00000038 00010000
qemu-system-x86_64: terminating on signal 1 from pid 196909 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 915498465
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107836687
Startup trace (nsec): print config: 109351510
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 551235898
Startup trace (nsec): initialize elements: 554857074
[    0.558808] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 566393354
[router_thread:310] Starting driver...


Received packet from device: 577166897 ns:  120 | 33330000 0016feee ae65bd5d 86dd6000 00000038 00010000
qemu-system-x86_64: terminating on signal 1 from pid 196987 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 920219577
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107757783
Startup trace (nsec): print config: 109242416
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 550291332
Startup trace (nsec): initialize elements: 553884982
[    0.557818] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 565347691
[router_thread:310] Starting driver...


Received packet from device: 576038647 ns:  180 | 33330000 0016767e 90d49854 86dd6000 00000074 0001fe80
qemu-system-x86_64: terminating on signal 1 from pid 197066 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 920905691
path '/home/okelmann/appclick-ubpf/benchmark' does not contain a 'flake.nix', searching up
warning: Git tree '/home/okelmann/appclick-ubpf' is dirty
Using saved setting for 'extra-substituters = https://tum-dse.cachix.org' from ~/.local/share/nix/trusted-settings.json.
Using saved setting for 'extra-trusted-public-keys = tum-dse.cachix.org-1:v67rK18oLwgO0Z4b69l30SrV1yRtqxKpiHodG4YxhNM=' from ~/.local/share/nix/trusted-settings.json.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/bench-helper`
c[?7l[2J[0mSeaBIOS (version rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org)


iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BEFD0F40+BEF30F40 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from ROM..Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                         Telesto 0.16.3
Startup trace (nsec): click main(): 107870697
Startup trace (nsec): print config: 109378270
Received config (length 5697):
define($MAC0 52:54:00:12:34:56);
/* End unikraft-provided MAC preamble */
// From: https://github.com/kohler/click/blob/master/conf/thomer-nat.click
// Slightly modified to be compatible with Click on Unikraft. Functionality not guaranteed.
//
// This Click configuration implements a firewall and NAT, roughly based on the
// mazu-nat.click example.
//
// This example assumes there is one interface that is IP-aliased.  In this
// example, dev0 and dev0:0 have IP addresses 66.68.65.90 and 192.168.1.1,
// respectively.  There is a local network, 192.168.1.0/24, and an upstream
// gateway, 66.58.65.89.  Traffic from the local network is NATed.
//
// Connections can be initiated from the NAT box itself, also.
// 
// For bugs, suggestions, and, corrections, please email me.
//
// Author: Thomer M. Gil (click@thomer.com)

define($DEV0 0)

AddressInfo(
    dev0-in     172.44.0.2    172.44.0.2/24    00:0d:87:9d:1c:e9,
    dev0-ex     172.44.0.3                     00:0d:87:9d:1c:e9,
    gw-addr     172.44.0.1                     00:20:6f:14:54:c2
);


elementclass SniffGatewayDevice {
  $device |
  from :: FromDevice($device)
    -> Print2('Received packet from device')
    -> t1 :: Tee
    -> output;
  input -> q :: Queue(1024)
    -> t2 :: PullTee
    -> to :: ToDevice($device);
  t1[1] -> ToDevice;
  t2[1] -> ToDevice($device);
  ScheduleInfo(from .1, to 1);
}


device :: SniffGatewayDevice($DEV0);
arpq_in :: ARPQuerier(dev0-in) -> device;
ip_to_extern :: GetIPAddress(16)
        -> CheckIPHeader
        -> EtherEncap(0x800, dev0-ex, gw-addr)
        -> device;
ip_to_host :: EtherEncap(0x800, gw-addr, dev0-ex)
        -> ToDevice;
ip_to_intern :: GetIPAddress(16)
        -> CheckIPHeader
        -> arpq_in;

                 
arp_class :: Classifier(
        12/0806 20/0001,        // [0] ARP requests
        12/0806 20/0002,        // [1] ARP replies to host
        12/0800);               // [2] IP packets

device -> arp_class;

// ARP crap
arp_class[0] -> ARPResponder(dev0-in, dev0-ex) -> device;
arp_class[1] -> arp_t :: Tee;
                arp_t[0] -> ToDevice;
                arp_t[1] -> [1]arpq_in;


// IP packets
arp_class[2] -> Strip(14)
   -> CheckIPHeader
   -> ipclass :: IPClassifier(dst host dev0-ex,
                              dst host dev0-in,
                              src net dev0-in);

// Define pattern NAT
iprw :: IPRewriterPatterns(NAT dev0-ex 50000-65535 - -);

// Rewriting rules for UDP/TCP packets
// output[0] rewritten to go into the wild
// output[1] rewritten to come back from the wild or no match
rw :: IPRewriter(pattern NAT 0 1,
                 pass 1);

// Rewriting rules for ICMP packets
irw :: ICMPPingRewriter(pass);
irw[0] -> ip_to_extern;
irw[1] -> icmp_me_or_intern :: IPClassifier(dst host dev0-ex, -);
          icmp_me_or_intern[0] -> ip_to_host;
          icmp_me_or_intern[1] -> ip_to_intern;

// Rewriting rules for ICMP error packets
ierw :: ICMPRewriter(rw irw);
ierw[0] -> icmp_me_or_intern;
ierw[1] -> icmp_me_or_intern;


// Packets directed at dev0-ex.
// Send it through IPRewriter(pass).  If there was a mapping, it will be
// rewritten such that dst is dev0-in:net, otherwise dst will still be for
// dev0-ex.
ipclass[0] -> Print("->1x") -> [1]rw;

// packets that were rewritten, heading into the wild world.
rw[0] -> Print("0->") -> ip_to_extern;

// packets that come back from the wild or are not part of an established
// connection.
rw[1] -> Print("1->") -> established_class :: IPClassifier(dst host dev0-ex,
                                           dst net dev0-in);

         // not established yet or returning packets for a connection that was
         // established from this host itself.
         established_class[0] ->
           firewall :: IPClassifier(dst tcp port ssh,
                                    dst tcp port smtp,
                                    dst tcp port domain,
                                    dst udp port domain,
                                    icmp type echo-reply,
                                    proto icmp,
                                    port > 4095,
                                    -);

                                    firewall[0] -> ip_to_host; // ssh
                                    firewall[1] -> ip_to_host; // smtp
                                    firewall[2] -> ip_to_host; // domain (t)
                                    firewall[3] -> ip_to_host; // domain (u)
                                    firewall[4] -> [0]irw;     // icmp reply
                                    firewall[5] -> [0]ierw;    // other icmp
                                    firewall[6] -> ip_to_host; // port > 4095, probably for connection
                                                               // originating from host itself
                                    firewall[7] -> Discard;    // don't allow incoming for port <= 4095

        // established connection
        established_class[1] -> ip_to_intern;

// To dev0-in.  Only accept from inside network.
ipclass[1] -> IPClassifier(src net dev0-in) -> ip_to_host;

// Packets from dev0-in:net either stay on local network or go to the wild.
// Those that go into the wild need to go through the appropriate rewriting
// element.  (Either UDP/TCP rewriter or ICMP rewriter.)
ipclass[2] -> inter_class :: IPClassifier(dst net dev0-in, -);
              inter_class[0] -> ip_to_intern;
              inter_class[1] -> ip_udp_class :: IPClassifier(tcp or udp,
                                                             icmp type echo);
                                ip_udp_class[0] -> Print("->0") -> [0]rw;
                                ip_udp_class[1] -> [0]irw;

Startup trace (nsec): print config done: 550684793
Startup trace (nsec): initialize elements: 554293583
[    0.558237] ERR:  [libvirtio_net] <virtio_net.c @  334> Failed to add a buffer to receive virtqueue 0x400064020: -28
Startup trace (nsec): initialize elements done: 565809174
[router_thread:310] Starting driver...


Received packet from device: 576564644 ns:  120 | 33330000 0016fe2c bb643271 86dd6000 00000038 00010000
qemu-system-x86_64: terminating on signal 1 from pid 197145 (/nix/store/h3b1h0p481wd0zrbkq71gw2m7gq13m83-sudo-1.9.17p2/bin/sudo)
Bench-helper startup time (nsec): 919710392
